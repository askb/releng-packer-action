---
# SPDX-License-Identifier: Apache-2.0
# SPDX-FileCopyrightText: 2025 The Linux Foundation

name: "Packer Build with OpenStack Tailscale Bastion"
description: "Build OpenStack images using Packer through a Tailscale bastion host"
author: "The Linux Foundation"

inputs:
  # Operation Mode
  mode:
    description: "Operation mode: 'validate' (syntax check only) or 'build' (full build with bastion)"
    required: false
    default: "build"

  # Packer Configuration
  packer_template:
    description: "Path to Packer template file (relative to packer_working_dir) - if empty, auto-discovers all templates in validate mode"
    required: false
    default: ""
  packer_vars_file:
    description: "Path to Packer variables file (relative to packer_working_dir) - if empty, auto-discovers all varfiles in validate mode"
    required: false
    default: ""
  packer_working_dir:
    description: "Working directory containing Packer files (will search for packer/ or common-packer/ subdirectory)"
    required: false
    default: "."
  path_prefix:
    description: "Directory path prefix for executing the action (prevents overwriting the caller's workspace)"
    required: false
    default: "."
  packer_version:
    description: "Packer version to use"
    required: false
    default: "1.11.2"
  os_cloud:
    description: "OpenStack cloud name from clouds.yaml (optional)"
    required: false
    default: ""

  # Cloud Configuration Files (base64 encoded)
  cloud_env_json:
    description: "Cloud environment JSON configuration (base64 encoded) - optional, will be generated from openstack_* inputs if not provided"
    required: false
    default: ""
  clouds_yaml:
    description: "OpenStack clouds.yaml configuration (base64 encoded, optional)"
    required: false
    default: ""

  # OpenStack/OpenStack Credentials
  openstack_auth_url:
    description: "OpenStack/OpenStack auth URL"
    required: false
    default: ""
  openstack_project_id:
    description: "OpenStack/OpenStack project/tenant ID"
    required: false
    default: ""
  openstack_username:
    description: "OpenStack/OpenStack username"
    required: false
    default: ""
  openstack_password:
    description: "OpenStack/OpenStack password (will be base64 decoded if needed)"
    required: false
    default: ""
  openstack_region:
    description: "OpenStack/OpenStack region"
    required: false
    default: "ca-ymq-1"
  openstack_network_id:
    description: "OpenStack/OpenStack network UUID for Packer builds"
    required: false
    default: ""

  # Bastion Configuration
  bastion_flavor:
    description: "OpenStack flavor for bastion instance"
    required: false
    default: "v3-standard-2"
  bastion_image:
    description: "Base image for bastion host"
    required: false
    default: "Ubuntu 22.04.5 LTS (x86_64) [2025-03-27]"
  bastion_network:
    description: "Network name for bastion host"
    required: false
    default: "odlci"
  bastion_ssh_key:
    description: "SSH key name for bastion (optional, Tailscale SSH used by default)"
    required: false
    default: ""
  bastion_wait_timeout:
    description: "Timeout in seconds to wait for bastion to be ready"
    required: false
    default: "300"

  # Tailscale Configuration (required for build mode only)
  # OAuth is the recommended method - requires both client_id and secret
  tailscale_oauth_client_id:
    description: "Tailscale OAuth client ID (recommended - requires oauth_secret)"
    required: false
    default: ""
  tailscale_oauth_secret:
    description: "Tailscale OAuth secret (recommended - requires oauth_client_id)"
    required: false
    default: ""
  # Legacy auth key support - deprecated but still supported
  tailscale_auth_key:
    description: "Tailscale auth key (legacy - OAuth is recommended)"
    required: false
    default: ""
  tailscale_tags:
    description: "Comma-separated list of Tailscale tags (e.g., 'tag:ci,tag:bastion')"
    required: false
    default: "tag:ci"
  tailscale_version:
    description: "Tailscale version"
    required: false
    default: "latest"

  # Build Options
  debug_mode:
    description: "Enable debug logging"
    required: false
    default: "false"
  upload_logs:
    description: "Upload build logs as artifacts"
    required: false
    default: "true"
  log_retention_days:
    description: "Days to retain log artifacts"
    required: false
    default: "30"

outputs:
  bastion_ip:
    description: "Tailscale IP of the bastion host (build mode only)"
    value: ${{ steps.get-bastion-ip.outputs.bastion_ip }}
  status:
    description: "Status of the operation (success/failure)"
    value: ${{ steps.packer-operation.outputs.status || steps.packer-validate.outputs.status }}
  mode:
    description: "Mode that was executed (validate/build)"
    value: ${{ inputs.mode }}

runs:
  using: "composite"
  steps:
    # ========================================
    # Step 0: Setup and validate path_prefix
    # ========================================
    - name: Setup working directory and validate path_prefix
      shell: bash
      run: |
        path_prefix="${{ inputs.path_prefix }}"

        # Validate path_prefix is not empty
        if [[ -z "$path_prefix" ]]; then
          echo "Error: path_prefix cannot be empty" >&2
          exit 1
        fi

        # Check for dangerous characters or paths
        if [[ "$path_prefix" =~ \.\./|^\.\.$|/\.\./|/\.\.$|^\.\.|^/ ]]; then
          echo "Error: path_prefix cannot contain '..' (parent directory references) or start with '/' (absolute paths)" >&2
          exit 1
        fi

        # Create the directory if it doesn't exist and it's not the default
        if [[ "$path_prefix" != "." && ! -d "${{ github.workspace }}/$path_prefix" ]]; then
          echo "Creating directory: $path_prefix" >&2
          mkdir -p "${{ github.workspace }}/$path_prefix"
        fi

        # Copy packer_working_dir contents to path_prefix if not using default
        if [[ "$path_prefix" != "." && -d "${{ inputs.packer_working_dir }}" ]]; then
          echo "Copying ${{ inputs.packer_working_dir }} to $path_prefix/" >&2
          cp -r "${{ inputs.packer_working_dir }}" "${{ github.workspace }}/$path_prefix/"
        fi

        echo "Path prefix validation and setup completed: $path_prefix" >&2

    # ========================================
    # Step 1: Setup Tailscale VPN (Build Mode Only)
    # ========================================
    - name: Setup Tailscale VPN (OAuth)
      if: inputs.mode == 'build' && inputs.tailscale_oauth_client_id != '' && inputs.tailscale_oauth_secret != ''
      uses: tailscale/github-action@a392da0a182bba0e9613b6243ebd69529b1878aa # v4.1.0
      with:
        oauth-client-id: ${{ inputs.tailscale_oauth_client_id }}
        oauth-secret: ${{ inputs.tailscale_oauth_secret }}
        version: ${{ inputs.tailscale_version }}
        tags: ${{ inputs.tailscale_tags }}
        hostname: github-runner-${{ github.run_id }}
        args: --ssh --accept-routes --accept-dns=false

    - name: Setup Tailscale VPN (Auth Key - Legacy)
      if: inputs.mode == 'build' && (inputs.tailscale_oauth_client_id == '' || inputs.tailscale_oauth_secret == '') && inputs.tailscale_auth_key != ''
      uses: tailscale/github-action@a392da0a182bba0e9613b6243ebd69529b1878aa # v4.1.0
      with:
        authkey: ${{ inputs.tailscale_auth_key }}
        version: ${{ inputs.tailscale_version }}
        hostname: github-runner-${{ github.run_id }}
        args: --ssh --accept-routes --accept-dns=false

    - name: Validate Tailscale credentials
      if: inputs.mode == 'build'
      shell: bash
      run: |
        if [[ -z "${{ inputs.tailscale_oauth_client_id }}" ]] && [[ -z "${{ inputs.tailscale_auth_key }}" ]]; then
          echo "‚ùå Error: Either tailscale_oauth_client_id+tailscale_oauth_secret OR tailscale_auth_key must be provided for build mode"
          exit 1
        fi

        if [[ -n "${{ inputs.tailscale_oauth_client_id }}" ]] && [[ -z "${{ inputs.tailscale_oauth_secret }}" ]]; then
          echo "‚ùå Error: tailscale_oauth_secret is required when tailscale_oauth_client_id is provided"
          exit 1
        fi

        if [[ -n "${{ inputs.tailscale_oauth_secret }}" ]] && [[ -z "${{ inputs.tailscale_oauth_client_id }}" ]]; then
          echo "‚ùå Error: tailscale_oauth_client_id is required when tailscale_oauth_secret is provided"
          exit 1
        fi

    - name: Verify Tailscale connection
      if: inputs.mode == 'build'
      shell: bash
      run: |
        echo "‚úÖ Tailscale status:"
        sudo tailscale status

    # ========================================
    # Step 2: Setup OpenStack CLI (Build Mode Only)
    # ========================================
    - name: Install OpenStack CLI
      if: inputs.mode == 'build'
      shell: bash
      run: |
        pip install python-openstackclient

    - name: Configure OpenStack credentials
      if: inputs.mode == 'build'
      shell: bash
      env:
        OS_AUTH_URL: ${{ inputs.openstack_auth_url }}
        OS_PROJECT_ID: ${{ inputs.openstack_project_id }}
        OS_USERNAME: ${{ inputs.openstack_username }}
        OS_PASSWORD: ${{ inputs.openstack_password }}
        OS_REGION_NAME: ${{ inputs.openstack_region }}
      run: |
        # Check if password is base64 encoded and decode if needed
        if echo "$OS_PASSWORD" | base64 -d &>/dev/null; then
          PASSWORD=$(echo "$OS_PASSWORD" | base64 -d)
        else
          PASSWORD="$OS_PASSWORD"
        fi

        echo "OS_AUTH_URL=${OS_AUTH_URL}" >> $GITHUB_ENV
        echo "OS_PROJECT_ID=${OS_PROJECT_ID}" >> $GITHUB_ENV
        echo "OS_USERNAME=${OS_USERNAME}" >> $GITHUB_ENV
        echo "OS_PASSWORD=${PASSWORD}" >> $GITHUB_ENV
        echo "OS_REGION_NAME=${OS_REGION_NAME}" >> $GITHUB_ENV
        echo "OS_IDENTITY_API_VERSION=3" >> $GITHUB_ENV
        echo "OS_USER_DOMAIN_NAME=Default" >> $GITHUB_ENV
        echo "OS_PROJECT_DOMAIN_NAME=Default" >> $GITHUB_ENV

    # ========================================
    # Step 3: Create and Launch Bastion Host (Build Mode Only)
    # ========================================
    - name: Create cloud-init script for bastion
      if: inputs.mode == 'build'
      shell: bash
      run: |
        BASTION_NAME="bastion-gh-${{ github.run_id }}"

        cat > cloud-init.yaml <<'EOF'
        #cloud-config
        hostname: ${BASTION_HOSTNAME}
        manage_etc_hosts: true
        package_update: true
        package_upgrade: true
        packages:
          - curl
          - wget
          - jq
          - net-tools
        write_files:
          - path: /usr/local/bin/bastion-init.sh
            content: |
              #!/bin/bash
              set -e
              echo "[$(date)] Installing Tailscale..."
              curl -fsSL https://tailscale.com/install.sh | sh
              tailscale up --authkey="${TAILSCALE_AUTH_KEY}" \
                --hostname="${BASTION_HOSTNAME}" \
                --advertise-tags=tag:bastion \
                --ssh --accept-routes --accept-dns=false
              TAILSCALE_IP=$(tailscale ip -4)
              echo "[$(date)] Tailscale IP: ${TAILSCALE_IP}"
              echo "READY" > /tmp/bastion-ready
            permissions: '0755'
        runcmd:
          - /usr/local/bin/bastion-init.sh
        EOF

        # Substitute variables
        sed -i "s/\${BASTION_HOSTNAME}/$BASTION_NAME/g" cloud-init.yaml
        sed -i "s/\${TAILSCALE_AUTH_KEY}/${{ inputs.tailscale_auth_key }}/g" cloud-init.yaml

        echo "BASTION_NAME=$BASTION_NAME" >> $GITHUB_ENV

    - name: Launch bastion instance
      if: inputs.mode == 'build'
      shell: bash
      run: |
        openstack server create \
          --flavor "${{ inputs.bastion_flavor }}" \
          --image "${{ inputs.bastion_image }}" \
          --nic net-id=${{ inputs.bastion_network }} \
          --user-data cloud-init.yaml \
          --wait \
          "${{ env.BASTION_NAME }}"

    - name: Wait for bastion to join Tailscale
      if: inputs.mode == 'build'
      shell: bash
      run: |
        timeout=${{ inputs.bastion_wait_timeout }}
        elapsed=0

        while [ $elapsed -lt $timeout ]; do
          if sudo tailscale status | grep -q "${{ env.BASTION_NAME }}"; then
            BASTION_IP=$(sudo tailscale status | grep "${{ env.BASTION_NAME }}" | awk '{print $1}')
            echo "‚úÖ Bastion joined Tailscale: $BASTION_IP"
            echo "BASTION_IP=$BASTION_IP" >> $GITHUB_ENV
            exit 0
          fi
          sleep 5
          elapsed=$((elapsed + 5))
        done

        echo "‚ùå Bastion failed to join Tailscale within ${timeout}s"
        exit 1

    - name: Export bastion IP
      if: inputs.mode == 'build'
      id: get-bastion-ip
      shell: bash
      run: |
        echo "bastion_ip=${{ env.BASTION_IP }}" >> $GITHUB_OUTPUT

    # ========================================
    # Step 4: Setup Python and Ansible (All Modes)
    # ========================================
    - name: Setup Python
      uses: actions/setup-python@a26af69be951a213d495a4c3e4e4022e16d87065 # v5.6.0
      with:
        python-version: "3.11"

    - name: Install Ansible
      shell: bash
      run: |
        python -m pip install --upgrade pip
        pip install ansible~=9.2.0

    - name: Install Ansible Galaxy requirements
      shell: bash
      working-directory: ${{ github.workspace }}/${{ steps.setup-path.outputs.path_prefix }}/${{ inputs.packer_working_dir }}
      run: |
        # Look for common-packer directory (could be a submodule)
        if [[ -d "common-packer" ]]; then
          COMMON_PACKER_DIR="common-packer"
        elif [[ -d "packer/common-packer" ]]; then
          COMMON_PACKER_DIR="packer/common-packer"
        else
          echo "‚ö†Ô∏è Warning: common-packer directory not found. Skipping ansible-galaxy requirements."
          exit 0
        fi

        # Install common-packer Ansible Galaxy requirements
        if [[ -f "$COMMON_PACKER_DIR/requirements.yaml" ]]; then
          echo "üì¶ Installing Ansible Galaxy requirements from $COMMON_PACKER_DIR/requirements.yaml"
          ansible-galaxy install -p .galaxy -r "$COMMON_PACKER_DIR/requirements.yaml"
        else
          echo "‚ö†Ô∏è Warning: $COMMON_PACKER_DIR/requirements.yaml not found"
        fi

        # Install project-specific requirements if they exist
        if [[ -f "requirements.yaml" ]]; then
          echo "üì¶ Installing project-specific Ansible Galaxy requirements"
          ansible-galaxy install -p .galaxy -r requirements.yaml
        fi

    # ========================================
    # Step 5: Setup Packer
    # ========================================
    - name: Setup Packer
      uses: hashicorp/setup-packer@1aa358be5cf73883762b302a3a03abd66e75b232 # v3.1.0
      with:
        version: ${{ inputs.packer_version }}

    - name: Create cloud environment file
      shell: bash
      run: |
        # Check if cloud_env_json is provided
        if [ -n "${{ inputs.cloud_env_json }}" ]; then
          # Use provided cloud_env_json
          if echo "${{ inputs.cloud_env_json }}" | base64 -d &>/dev/null 2>&1; then
            echo "${{ inputs.cloud_env_json }}" | base64 -d > cloud-env.json
          else
            echo '${{ inputs.cloud_env_json }}' > cloud-env.json
          fi
          echo "‚úÖ Using provided cloud_env_json"
        elif [ -n "${{ inputs.openstack_auth_url }}" ]; then
          # Generate cloud-env from openstack credentials
          # Decode password if base64 encoded
          if echo "${{ inputs.openstack_password }}" | base64 -d &>/dev/null 2>&1; then
            CLOUD_PASS=$(echo "${{ inputs.openstack_password }}" | base64 -d)
          else
            CLOUD_PASS="${{ inputs.openstack_password }}"
          fi

          # Create cloud-env.json
          cat > cloud-env.json <<EOF
        {
          "cloud_auth_url": "${{ inputs.openstack_auth_url }}",
          "cloud_tenant": "${{ inputs.openstack_project_id }}",
          "cloud_user": "${{ inputs.openstack_username }}",
          "cloud_pass": "${CLOUD_PASS}",
          "cloud_network": "${{ inputs.openstack_network_id }}"
        }
        EOF
          echo "‚úÖ Generated cloud_env_json from openstack credentials"
        else
          echo "‚ö†Ô∏è No cloud environment configuration provided"
        fi

        # Update ssh_proxy_host with bastion IP (build mode only)
        if [ "${{ inputs.mode }}" == "build" ] && [ -f "cloud-env.json" ]; then
          jq --arg ip "${{ env.BASTION_IP }}" '.ssh_proxy_host = $ip' cloud-env.json > cloud-env.tmp.json
          mv cloud-env.tmp.json cloud-env.json
          echo "‚úÖ Updated cloud-env.json with bastion IP: ${{ env.BASTION_IP }}"
        fi

    - name: Create clouds.yaml (optional)
      if: inputs.clouds_yaml != ''
      shell: bash
      run: |
        mkdir -p "$HOME/.config/openstack"
        echo "${{ inputs.clouds_yaml }}" | base64 -d > "$HOME/.config/openstack/clouds.yaml"
        echo "‚úÖ OpenStack clouds.yaml created"

    - name: Setup SSH agent (Build Mode)
      if: inputs.mode == 'build'
      shell: bash
      run: |
        eval "$(ssh-agent -s)"
        echo "SSH_AUTH_SOCK=$SSH_AUTH_SOCK" >> $GITHUB_ENV
        echo "SSH_AGENT_PID=$SSH_AGENT_PID" >> $GITHUB_ENV
        echo "‚úÖ SSH agent started"

    # ========================================
    # Step 6: Run Packer Operation
    # ========================================
    - name: Determine packer directory
      shell: bash
      run: |
        WORK_DIR="${{ github.workspace }}/${{ inputs.path_prefix }}/${{ inputs.packer_working_dir }}"

        # Check if packer_working_dir points to a subdirectory with packer files
        if [ -d "$WORK_DIR/packer" ]; then
          PACKER_DIR="$WORK_DIR/packer"
        elif [ -d "$WORK_DIR/common-packer" ]; then
          PACKER_DIR="$WORK_DIR/common-packer"
        else
          PACKER_DIR="$WORK_DIR"
        fi

        echo "PACKER_DIR=$PACKER_DIR" >> $GITHUB_ENV
        echo "Using packer directory: $PACKER_DIR"

    - name: Validate all Packer templates (Validate Mode)
      if: inputs.mode == 'validate'
      id: packer-validate
      shell: bash
      env:
        OS_CLOUD: ${{ inputs.os_cloud }}
      run: |
        set -x

        cd "$PACKER_DIR"

        # Determine validation mode: auto-discovery or explicit paths
        EXPLICIT_TEMPLATE="${{ inputs.packer_template }}"
        EXPLICIT_VARFILE="${{ inputs.packer_vars_file }}"

        validation_count=0
        failed_count=0

        # Create logs directory
        mkdir -p "${{ github.workspace }}/logs"
        PACKER_LOGS_DIR="${{ github.workspace }}/logs"

        # Create minimal cloud-env file for validation (if it doesn't exist)
        if [ ! -f "${{ github.workspace }}/cloud-env.pkrvars.hcl" ] && [ ! -f "${{ github.workspace }}/cloud-env.json" ]; then
          echo "Creating minimal cloud-env for validation..."
          cat > "${{ github.workspace }}/cloud-env.pkrvars.hcl" <<EOF
        # Minimal cloud environment for packer validation
        cloud_auth_url      = "https://example.com:5000/v3"
        cloud_tenant_name   = "validation-tenant"
        cloud_username      = "validation-user"
        cloud_password      = "validation-pass"
        cloud_region        = "RegionOne"
        cloud_network       = "validation-network"
        cloud_domain_name   = "default"
        EOF
        fi

        # Function to validate a template with a varfile
        validate_template() {
          local varfile="$1"
          local template="$2"

          echo "  ‚Üí Validating: $template with $varfile"

          # Initialize template if needed
          if [[ "${template#*.}" == "pkr.hcl" ]]; then
            echo "    Initializing template..."
            if ! packer init "$template" 2>&1; then
              echo "    ‚ùå Failed to initialize $template"
              return 1
            fi
          fi

          # Set up logging
          LOG_FILE="packer-validate-${varfile##*/}-${template##*/}.log"
          export PACKER_LOG="yes"
          export PACKER_LOG_PATH="$PACKER_LOGS_DIR/$LOG_FILE"

          # Build validation command
          VALIDATE_CMD="packer validate -syntax-only"

          # Add cloud-env if it exists
          if [ -f "${{ github.workspace }}/cloud-env.pkrvars.hcl" ]; then
            VALIDATE_CMD="$VALIDATE_CMD -var-file=${{ github.workspace }}/cloud-env.pkrvars.hcl"
          elif [ -f "${{ github.workspace }}/cloud-env.json" ]; then
            VALIDATE_CMD="$VALIDATE_CMD -var-file=${{ github.workspace }}/cloud-env.json"
          fi

          # Add varfile and template
          VALIDATE_CMD="$VALIDATE_CMD -var-file=$varfile $template"

          # Run validation
          echo "    Running: $VALIDATE_CMD"
          if output=$(eval "$VALIDATE_CMD" 2>&1); then
            echo "    ‚úÖ Validation passed"
            return 0
          else
            echo "    ‚ùå Validation failed: $output"
            return 1
          fi
        }

        # Check if explicit paths are provided
        if [[ -n "$EXPLICIT_TEMPLATE" && -n "$EXPLICIT_VARFILE" ]]; then
          echo "======================================"
          echo "Validating explicit template"
          echo "======================================"
          echo "Template: $EXPLICIT_TEMPLATE"
          echo "Varfile: $EXPLICIT_VARFILE"

          if validate_template "$EXPLICIT_VARFILE" "$EXPLICIT_TEMPLATE"; then
            ((validation_count++)) || true
          else
            ((failed_count++)) || true
          fi
        else
          echo "======================================"
          echo "Auto-discovering Packer files"
          echo "======================================"

          # Find all varfiles and templates
          varfiles=()
          if [ -d "vars" ]; then
            while IFS= read -r -d '' file; do
              varfiles+=("$file")
            done < <(find vars -type f -name "*.pkrvars.hcl" -print0 2>/dev/null || true)
          fi
          if [ -d "common-packer/vars" ]; then
            while IFS= read -r -d '' file; do
              varfiles+=("$file")
            done < <(find common-packer/vars -type f -name "*.pkrvars.hcl" -print0 2>/dev/null || true)
          fi

          templates=()
          if [ -d "templates" ]; then
            while IFS= read -r -d '' file; do
              templates+=("$file")
            done < <(find templates -type f -name "*.pkr.hcl" -print0 2>/dev/null || true)
          fi

          echo "Found ${#varfiles[@]} varfile(s) and ${#templates[@]} template(s)"

          # Loop through each varfile
          for varfile in "${varfiles[@]}"; do
            # Skip cloud-env files
            if [[ "$varfile" == *"cloud-env"* ]]; then
              echo "Skipping $varfile (cloud-env)"
              continue
            fi

            echo "::group::Validating with $varfile"
            echo "======================================"
            echo "Testing varfile: $varfile"
            echo "======================================"

            # Loop through each template
            for template in "${templates[@]}"; do
              # Skip variables files
              if [[ "$template" == *"variables"* ]]; then
                continue
              fi

              if validate_template "$varfile" "$template"; then
                ((validation_count++)) || true
              else
                ((failed_count++)) || true
              fi
            done
            echo "::endgroup::"
          done
        fi

        echo ""
        echo "======================================"
        echo "Validation Summary"
        echo "======================================"
        echo "Total validations passed: $validation_count"
        echo "Total validations failed: $failed_count"
        echo "======================================"

        # Set output
        if [ $failed_count -gt 0 ]; then
          echo "status=failure" >> "$GITHUB_OUTPUT"
          echo "‚ùå $failed_count validation(s) failed"
          exit 1
        else
          echo "status=success" >> "$GITHUB_OUTPUT"
          echo "‚úÖ All $validation_count validations passed"
        fi

    - name: Initialize Packer (Build Mode)
      if: inputs.mode == 'build'
      shell: bash
      run: |
        cd "$PACKER_DIR"
        packer init "${{ inputs.packer_template }}"

    - name: Validate Packer template (Build Mode)
      if: inputs.mode == 'build'
      shell: bash
      env:
        OS_CLOUD: ${{ inputs.os_cloud }}
      run: |
        set -e
        cd "$PACKER_DIR"

        VALIDATE_CMD="packer validate -syntax-only"
        VALIDATE_CMD="$VALIDATE_CMD -var-file=${{ github.workspace }}/cloud-env.json"
        VALIDATE_CMD="$VALIDATE_CMD -var-file=${{ inputs.packer_vars_file }}"
        VALIDATE_CMD="$VALIDATE_CMD -var=bastion_host=${{ env.BASTION_IP }}"
        VALIDATE_CMD="$VALIDATE_CMD ${{ inputs.packer_template }}"

        echo "Running: $VALIDATE_CMD"
        if $VALIDATE_CMD; then
          echo "‚úÖ Packer validation successful"
        else
          echo "‚ùå Packer validation failed"
          exit 1
        fi

    - name: Build with Packer (Build Mode Only)
      if: inputs.mode == 'build'
      id: packer-operation
      shell: bash
      env:
        PACKER_LOG: ${{ inputs.debug_mode == 'true' && '1' || '0' }}
        OS_CLOUD: ${{ inputs.os_cloud }}
      run: |
        set +e
        cd "$PACKER_DIR"

        packer build \
          -var-file="${{ github.workspace }}/cloud-env.json" \
          -var-file="${{ inputs.packer_vars_file }}" \
          -var="bastion_host=${{ env.BASTION_IP }}" \
          -var="bastion_user=root" \
          "${{ inputs.packer_template }}"

        BUILD_EXIT_CODE=$?

        if [ $BUILD_EXIT_CODE -eq 0 ]; then
          echo "status=success" >> $GITHUB_OUTPUT
          echo "‚úÖ Packer build completed successfully"
          exit 0
        else
          echo "status=failure" >> $GITHUB_OUTPUT
          echo "‚ùå Packer build failed with exit code $BUILD_EXIT_CODE"
          exit $BUILD_EXIT_CODE
        fi

    # ========================================
    # Step 7: Cleanup
    # ========================================
    - name: Cleanup bastion instance
      if: always() && inputs.mode == 'build'
      shell: bash
      run: |
        openstack server delete --wait "${{ env.BASTION_NAME }}" || true
        echo "‚úÖ Bastion instance cleaned up"
